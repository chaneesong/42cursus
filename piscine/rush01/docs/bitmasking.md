# Bit Masking 비트 마스킹

> 마스크(mask) 또는 비트마스크(bitmask)는 특히 비트 필드에서 비트 연산에 사용되는  
> 데이터이다. 마스크를 사용하면 바이트, 니블, 워드 등의 다중 비트들을 싱글 비트 연산
> `>>` 작업에서 켜고 끄거나 상호 반전시킬 수 있다. [wiki]

## 비트마스크의 장점

1. 수행 시간이 짧다

    bit 연산을 사용하기 때문에 O(1) 에 구현되는 것이 많다. 다른 자료구조를 사용하는 것 보다 빠르게 작동한다.

2. 간결하게 코드 작성이 가능하다.

    다양한 집합연산을 비트 연산자 한줄로 작성할수 있다.

3. 메모리 사용량이 적다.

    일반적인 int 범위인 32bit를 기준으로 $2^{32}$ 가지 경우의 수를 int 하나로 표현할 수 있다. 많은 데이터를 기록하는데 무리가 없다.

Bit 연산자들의 우선 순위는 비교 연산자 보다 낮기 때문에 괄호안에 쓰는것이 안전하다.

사용하는 자료형에 따라 Overflow 가 발생할수있다. Overflow 가 발생하게 되면 예상했던 결과와 전혀 다른 값이 나올수도 있기때문에 주의해야한다.

## 비트마스크를 이용한 집합연산

N 비트의 정수로 N개의 원소를 갖는 집합의 모든 부분집합 $2^N$ 을 표현할수 있다.

비트가 1(켜져있다) 또는 0 (꺼져있다) 있다로 집합의 원소가 있는지 표현이 가능하다.

예시

전체집합의 원소가 4개일때 꽉찬 집합 `1111`

전체집합의 원소가 4개일때 공집합 `0000`

- 공집합과 꽉찬 집합

```c
int empty = 0 // 공집합 b0000
int full = (1 << 4) - 1 // 꽉찬 집합 b1111
```

- 원소의 추가

i 번째 원소를 추가한다

i 번째 비트를 1로 바꾼다

```c
S |= 1 << i;
```

```c
int S = 0; // 공집합 b0000
S |= (1 << 2); // b0000 or b0100 = b0100
```

- 원소의 삭제

i 번째 원소를 삭재한다

i 번째 비트를 0으로 바꾼다

```c
S &= ~(1 << i)
```

```c
int S = 7 // b0111 원소가 4개 있는 집합
S &= ~(1 << 2) // b0111 & b1011 = b0011 2번째 원소 삭제
```

- 원소 포함 여부확인

```c
if (S & (1 << i)) // 포함되어있다면 1 << i 없다면 0
```

- 원소 토글

```c
S ^= (1 << i) // i 번째 bit 가 0이면 1로 1 이면 0 으로
```

- 두 집합에 대한 연산

```c
int ADD = S1 | S2 // 합집합
int INTERSECTION = S1 & S2 // 교집합
int SUB = (S1 & ~S2) // 차집합
int UNIQUE = (S1 ^ S2) // 두집합중 한쪽만 속해있는 원소들의 집합
```

- 최소 원소찾기

최하위 비트를 구하는 것과 동일하다

```c
S & -S
```

예시

```c
S = 14 // b1110
int first = S & -S // b00001110 & b11110010 = b0010
```

음수로 뒤집게 되면 2의 보수로 계산되어 ~S + 1이 된다

최하위 비트의 오른쪽 비트는 모두 0 이다 그렇기 때문에 비트 반전을 시킨 후 1을 더하게 되면 최하위 비트에만 1이 켜지게 된다

- 최소 원소 지우기

```c
S &= S - 1
```

S - 1 연산은 은 최하위 비트를 0으로 만든다

S = 1010 일때 S - 1 = 1001 이 된다

`1010 & 1001 = 1000`

최하위 비트가 꺼지게 된다.

